<?php

  module_load_include('inc', 'g3core', 'g3core.utils');
  
  module_load_include('inc', 'gb_maillist', 'gb_maillist.gfeature');  
  module_load_include('inc', 'gb_maillist', 'gb_maillist.constants');
  module_load_include('inc', 'gb_maillist', 'gb_maillist.queries');
  module_load_include('inc', 'gb_maillist', 'gb_maillist.api');
  
  function _is_forum_topic($node) {
    if ($node->type !== 'forum') {
      return FALSE;
    }
    
    if (php_sapi_name() != 'cli') {
      // Is this coming from the forum post topic form that we've hooked?
      if ($node->form_id != 'forum_node_form' && !isset($node->from_cli)) {
        return FALSE;
      }
    }
    
    return TRUE;
  }
  
  function _is_forum_comment($comment) {
    if ($comment->node_type !== 'comment_node_forum') {
      return FALSE;
    }
    
    if (php_sapi_name() != 'cli') {
      // Is this coming from the forum post comment form?
      if ($comment->form_id !== 'comment_node_forum_form') {
        return FALSE;
      }
    }
    
    return TRUE;
  }
  
  function _get_forum_tid_from_topic_node($node) {
    // Do we have an attached forum taxonomy?
    if (!isset($node->taxonomy_forums)) {
      return FALSE;
    }
    
    return $node->taxonomy_forums[LANGUAGE_NONE][0]['tid'];
  }
  
  /*
   * Fetch a list of outgoing email addresses from other modules
   * and sanitize the list in various ways.
   */
  function _fetch_outgoing_email_addresses($tid, $items) {
    $result = array();
    
    $lists = array();
    // Aggregate the items by module and storage class id
    foreach ($items as $item) {
      $module = $item['module'];
      $class_id = $item['class'];
      $item_id = $item['item'];
      
      $lists[$module][$class_id][] = $item_id;
    }
    
    // Get the e-mails from the providing modules
    foreach ($lists as $module => $classes) {
      foreach ($classes as $class_id => $items)
      // Get the emails for the item id
      $addresses = call_user_func($module . 
          '_provide_email_addresses_for_class_items', $class_id, $items);
      if (!empty($addresses)) {
        $result = array_merge($result, $addresses);
      }
    }
    
    // Filter out the duplicates
    $result = array_unique($result);
    
    $blacklisted = _fetch_blacklisted_emails_for_tid($tid);
    
    // Remove any blacklisted e-mails
    $result = array_diff($result, $blacklisted);
    
    // Give other modules a chance to alter the emails
    drupal_alter('outgoing_email_addresses', $result);
    
    return $result;
  }
  
  /* 
   * Retrieve the mailing list descriptors from other modules
   */
  function _fetch_mailing_list_descriptors() {
    $descriptors = array();
    // We have no default or provided descriptors
    // so let the other modules alter the descriptors
    drupal_alter('mailing_list_descriptors', $descriptors);
    
    foreach (array_keys($descriptors) as $key) {
      if (strlen($key) > DRUPAL_EXTENSION_NAME_MAX_LENGTH) {
        throw new Exception('Module name length exceeds ' . 
            'DRUPAL_EXTENSION_NAME_MAX_LENGTH');
      }
    } 
    
    return $descriptors;
  }
  
  /** Implements hook_TYPE_alter() */  
  function gb_maillist_email_alter(&$email) {
    // dpm($email);
  }
  
  function _get_base_url() {
    global $base_url;
    return $base_url;
  }
  
  function _dispatch_emails_for_post($nid, $metadata, $subject, $body, 
      $update, $plain, $attachment_fids) {
    $tid = $metadata['tid'];
    $list_type = $metadata['list_type'];
    $reply_to_type = $metadata['reply_to_type'];
    $reply_to_email = $metadata['reply_to_email'];
    
   watchdog('gb_maillist', '_dispatch');
    
    $items = _fetch_list_items_for_tid($tid);
    if (empty($items)) {
      // We should always have items attached to a mailing list
      drupal_set_message(t('Mailing list has no attached lists'), 'error');
      return;
    }
    
    $addresses = _fetch_outgoing_email_addresses($tid, $items);
    if (empty($addresses)) { 
      drupal_set_message(t('Failed to retrieve any emails for list'), 'error');
      return;
    }
    
    // Get some globals
    $base_url = _get_base_url();
    $user = g3core_get_user();
    $domain = g3core_get_domain();
    $alias = '';
    
    // global $user is not a complete object, no fields
    $user = user_load($user->uid);
    
    // Construct a username
    if (isset($user->field_first_name[LANGUAGE_NONE])) {
      $username = $user->field_first_name[LANGUAGE_NONE][0]['value'];
      if (isset($user->field_last_name[LANGUAGE_NONE])) {
        $username .= ' ';
        $username .= $user->field_last_name[LANGUAGE_NONE][0]['value'];
      }
    } else {
      $username = $user->name;
    }
    
    // Generate the reply-to e-mail
    if ($list_type == _MAILING_LIST_TYPE_BROADCAST) {
      if ($reply_to_type == _BROADCAST_REPLY_TO_TYPE_POSTERS_EMAIL) {
        $reply_to = "\"{$username}\" <{$user->mail}>";
      } elseif ($reply_to_type == _BROADCAST_REPLY_TO_TYPE_DO_NOT_REPLY) {
        $reply_to = "\"DO NOT REPLY\" <do_not_reply@{$domain}>";
      } elseif ($reply_to_type == _BROADCAST_REPLY_TO_TYPE_USER_DEFINED) {
        $reply_to = $reply_to_email;
      }
    } else { // _MAILING_LIST_TYPE_STANDARD
      if ($reply_to_type == _STANDARD_REPLY_TO_TYPE_MAILING_LIST) {
        $aliases = _fetch_list_aliases_for_tid($tid);
        if (empty($aliases)) {
          drupal_set_message(t('Failed to retrieve any aliases for the list'),
              'error');
          return;
        }
        $alias = $aliases[0]['alias'];
        $reply_to = "{$alias}@{$domain}";
        $from = "\"{$username}\" <{$reply_to}>"; // override from
      } elseif ($reply_to_type == _STANDARD_REPLY_TO_TYPE_POSTERS_EMAIL) {
        $reply_to = "\"{$username}\" <{$user->mail}>";
      }
    }
    
    if (is_null($reply_to)) {
      drupal_set_message(t('Failed to generate a reply-to e-mail'), 'error');
      return;
    }       
    
    // Set from to the reply-to or the user-defined variable
    if (!isset($from)) {
      $from = is_null($metadata['from_email']) ? 
          $reply_to : $metadata['from_email'];
    }
        
    // Set the sender and bounce handler
    // We'll use the alias for a standard list and the generic 'broadcast'
    // local address for broadcast lists, since we don't typically handle
    // incoming mail for them
    $sender = ($list_type == _MAILING_LIST_TYPE_STANDARD) ? 
        "{$alias}@{$domain}" : "broadcast@{$domain}";
    $bounces = "bounces@{$domain}";
    
    $dispatcher = new EmailDispatcher($sender, $bounces, TRUE);
    $operations = array();
    
    foreach ($addresses as $address) {
      $key = ($list_type == _MAILING_LIST_TYPE_STANDARD) ? 
          'standard' : 'broadcast';
      // Variables passed to theme
      $tokens = array(
        'tid' => $tid,
        'nid' => $nid,
        'reply_to' => $reply_to,
        'user' => $user,
      );
      $email = new EmailMimeEmail($key, $tokens);
      $email->set_paths($address, $from, $reply_to);
      $email->set_subject($subject);
      $email->set_main_body($body, $plain);
      if (!$plain) {
        $alt_body = 'To view this e-mail you need an HTML compatible client.';
        $email->set_alt_body($alt_body);
      }
      // Attach files
      if (!empty($attachment_fids)) {
        foreach ($attachment_fids as $fid) {
          $file = file_load($fid);
          $email->add_attachment($file->uri, $file->filemime);
        }
      }
      if ($list_type == _MAILING_LIST_TYPE_BROADCAST) {
        // Set unsubscribe for broadcast lists
        $mailto = "<mailto:unsubscribe-{$tid}@{$domain}>";
        $email->add_header('List-Unsubscribe', $mailto);
      } else {
        // Set headers for standard lists
        $email->add_header('Precedence', 'bulk');
        $email->add_header('List-Id', "<{$nid}.{$domain}>");
        $email->add_header('Message-Id', "<{$nid}.{$tid}@{$domain}>");
      }
    
      $operations[] = array('_dispatch_email', array($dispatcher, $email));
    }

    // Create a batch operation to send the e-mails
    $batch = array(
      'title' => t('Dispatching e-mail'),
      'operations' => $operations,
      'finished' => '_dispatch_email_finished',
      'file' => drupal_get_path('module', 'gb_maillist') . 
          '/gb_maillist.batch.inc',
    );
    
    batch_set($batch);
    
    watchdog('gb_maillist', php_sapi_name());
    
    // Run the batch if we've been invoked via drush
    if (php_sapi_name() == 'cli') {
      drush_backend_batch_process();
    }
  }

  function _node_update_and_insert($node) {
    watchdog('gb_maillist', 'node update & insert');
    
    if (!_is_forum_topic($node)) {
      return;
    }
    
    watchdog('gb_maillist', 'is_forum_topic');
    
    $tid = _get_forum_tid_from_topic_node($node);
    if (!$tid) {
      drupal_set_message(t('Forum node has no attached tid'), 'error');
      return;
    }
    
     watchdog('gb_maillist', 'got tid');
    
    $metadata = _fetch_list_metadata_for_tid($tid);
    if (!$metadata) {
      return; // There is no mailing list attached to this forum
    }
    
     watchdog('gb_maillist', 'got meta');
    
    $update = !$node->is_new;
    $body = $node->body[LANGUAGE_NONE][0]['value'];
    //$plain = ($node->body[LANGUAGE_NONE][0]['format'] === 'plain_text');
    $plain = FALSE; // always send HTML
    $subject = $node->title;
    $fids = array();
    if (isset($node->field_attachment[LANGUAGE_NONE])) {
      foreach ($node->field_attachment[LANGUAGE_NONE] as $attachment) {
        $fids[] = $attachment['fid'];
      }
    }
    _dispatch_emails_for_post($node->nid, $metadata, $subject, $body, 
        $update, $plain, $fids); 
  }
  
  function _comment_update_and_insert($comment) {
    watchdog('gb_maillist', 'comment update & insert');
    
    if (!_is_forum_comment($comment)) {
      return;
    }
    
    watchdog('gb_maillist', 'is_forum_comment');
    
    // Load the topic node to get the parent tid
    $node = node_load($comment->nid);
    $tid = _get_forum_tid_from_topic_node($node);
    if (!$tid) {
      drupal_set_message(t('Forum node has no attached tid'), 'error');
      return;
    }
    
    $metadata = _fetch_list_metadata_for_tid($tid);
    if (!$metadata) {
      return; // There is no mailing list attached to this forum
    }
    
    // Comment doesn't have the property is_new like node.
    // However, there is a 'new' property (integer) set to 0 for update
    // However, the property doesn't exist on insert?
    $update = FALSE;
    if (property_exists($comment, 'new')) {
      if ($comment->new === 0) {
        $update = TRUE;
      }
    }
    
    $comment_body = $comment->comment_body[LANGUAGE_NONE][0];
    //$plain = ($comment_body['format'] === 'plain_text');
    $plain = FALSE;
    $body = $comment_body['value'];
    $subject = $comment->subject;
    $fids = array();
    if (isset($comment->field_attachment[LANGUAGE_NONE])) {
      foreach ($comment->field_attachment[LANGUAGE_NONE] as $attachment) {
        $fids[] = $attachment['fid'];
      }
    }
    _dispatch_emails_for_post($node->nid, $metadata, $subject, $body, 
        $update, $plain, $fids);
  }

  function _extract_values_with_keys_that_match_pattern($values, $pattern) {
    $result = array();
    
    foreach ($values as $key => $value) {
      if (is_string($key)) {
        if (preg_match($pattern, $key)) {
          $result[$key] = $value;
        }
      }
    }
    
    return $result;
  }

  function _fetch_forum_form_default_values($tid) {
    $defaults = array(
        'attach_list' => 0,
        'list_type' => _MAILING_LIST_TYPE_BROADCAST,
        'broadcast_reply_to_type' => _BROADCAST_REPLY_TO_TYPE_POSTERS_EMAIL,
        'standard_reply_to_type' => _STANDARD_REPLY_TO_TYPE_POSTERS_EMAIL,
        'reply_to_email' => NULL,
        'from_email' => NULL,
        'user_defined_from' => NULL,
        'num_aliases' => 0,
     );
    
    if (!is_null($tid)) {
      $metadata = _fetch_list_metadata_for_tid($tid);
      if (!$metadata) { // No attached metadata?
        return $defaults;
      }
      
      if ($metadata['list_type'] == _MAILING_LIST_TYPE_BROADCAST) {
        $broadcast_reply_to_type = $metadata['reply_to_type'];
        $standard_reply_to_type = _STANDARD_REPLY_TO_TYPE_POSTERS_EMAIL;
      } else { // _MAILING_LIST_TYPE_STANDARD
        $broadcast_reply_to_type = _BROADCAST_REPLY_TO_TYPE_POSTERS_EMAIL;
        $standard_reply_to_type = $metadata['reply_to_type'];
      }
      
      $current = array(
        'attach_list' => 1,
        'list_type' => $metadata['list_type'],
        'broadcast_reply_to_type' => $broadcast_reply_to_type,
        'standard_reply_to_type' => $standard_reply_to_type,
        'reply_to_email' => $metadata['reply_to_email'],
        'from_email' => $metadata['from_email'],
        'user_defined_from' => empty($metadata['from_email']) ? 0 : 1,
      );
      
      $items = _fetch_list_items_for_tid($tid);
      if (empty($items)) {
        // We should always have items attached to a mailing list
        drupal_set_message(t('Mailing list has no attached lists'), 'error');
        return;
      }
      
      foreach ($items as $item) {
        // scid:<storage_class_id>
        $scid = 'scid:' . $item['class'];
        // iid:<module>:<storage_class_id>:<item_id>
        $siid = 'iid:' . $item['module'] . ':' . 
            $item['class'] . ':' . $item['item'];
        
        $current[$scid][] = $siid;
      }
      
      $aliases = _fetch_list_aliases_for_tid($tid);
      if (empty($aliases)) {
        $current['num_aliases'] = 0;
      } else {
        $n = count($aliases);
        $current['num_aliases'] = $n;
        while ($n-- > 0) {
          $current["alias_{$n}"] = $aliases[$n]['alias'];
        } 
      }

      return $current;
    }

    return $defaults;
  }

  /** Callback to replace the 'aliases' elements */
  function ajax_gb_maillist_add_alias($form, $form_state) {
    return $form['mailing_list_setup']['list_options']['aliases'];
  }
  
  /** Callback to replace the 'aliases' element */
  function ajax_gb_maillist_delete_alias($form, $form_state) {
    return $form['mailing_list_setup']['list_options']['aliases'];
  }
  
  /** Callback function to theme the 'aliases' */
  function theme_gb_maillist_aliases($container) {
    $elements = $container['aliases'];
    
    if (isset($elements['num_aliases']) && $elements['num_aliases'] > 0) {
      $variables = array(
        'header' => array(t('Aliases'), t('Delete')),
        'empty' => t("No aliases."),
        'rows' => array(),
        'attributes' => array(),
        'caption' => t("Aliases used to e-mail this list." .
            " Format: <em>alias</em>@domain" . 
            " (don't include the domain). Valid characters are lowercase" .
            " letters and underscores."),
        'colgroups' => array(),
        'sticky' => FALSE,
      );
      
      $num_aliases = $elements['num_aliases']['#value'];
      for ($i = 0; $i < $num_aliases; $i++) {
        $variables['rows'][$i][] = drupal_render($elements["alias_{$i}"]);
        $variables['rows'][$i][] = drupal_render($elements["del_alias_{$i}"]);
      }
      
      return theme_table($variables);
    }
  }
  
  /** Handles the logic for adding and removing aliases */
  function _aliases_ajax_logic(&$form, &$form_state, 
      $descriptors, $defaults) {
    // Set the number of aliases to 0 on form creation
    if (!isset($form_state['storage']['num_aliases'])) {
      $form_state['storage']['num_aliases'] = $defaults['num_aliases'];
    }
    
    // If we were brought here by the AJAX event to an alias than the number of
    // aliases has increased or decreased
    if (isset($form_state['triggering_element'])) {
      $matches = array();
      $name = $form_state['triggering_element']['#name'];
      if ($name === 'add_alias') { // brought here by add_alias
        if ($form_state['storage']['num_aliases'] < 5) { // cap of 5 aliases
          $form_state['storage']['num_aliases'] += 1;
        }
      } elseif (preg_match('/^del_alias_([0-5])$/', $name, $matches)) {
        $form_state['storage']['num_aliases'] -= 1;
        
        $new_num_aliases = $form_state['storage']['num_aliases'];
        $index_to_delete = $matches[1];
        
        // We need to rebuild & restructure the input array to preserve
        // the current input values
        $input = $form_state['input']['aliases'];
        unset($input["alias_{$index_to_delete}"]); // delete alias
        $values = array_values($input);  
        $keys = array();
        for ($i = 0; $i < $new_num_aliases; $i++) {
          $keys[] = "alias_{$i}";
        }
        // Assign the new input values
        $form_state['input']['aliases'] = array_combine($keys, $values);  
      }
    }
  }

  /**
   * Insert our elements into the forum form
   */
  function _insert_mailing_list_elements(&$form, &$form_state, 
      $descriptors, $defaults) {
    // Create the mailing list fieldset
    $form['mailing_list_setup'] = array(
      '#type' => 'fieldset',
      '#title' => 'Mailing list',
      '#collapsible' => TRUE,
    );
    $fieldset = &$form['mailing_list_setup'];
    
    // Checkbox whether or not to attach a mailing list
    $fieldset['attach_list'] = array(
      '#type' => 'checkbox',
      '#title' => t('Attach Mailing list'),
      '#decription' => t('Whether to include a mailing list'),
      '#return_value' => 1, 
      '#default_value' => $defaults['attach_list'], 
    );
    
    // Group of elements to set the list options 
    $fieldset['list_options'] = array(
      '#type' => 'fieldset',
      '#title' => t('List options'),
      //'#collapsible' => TRUE,
      //'#collapsed' => $collapsed,
      '#states' => array(
        // visible if we are attaching a list
        'visible' => array(
          ':input[name="attach_list"]' => array('checked' => TRUE),
        ),
      ),
    );
    $options = array(
      _MAILING_LIST_TYPE_STANDARD => t('Standard mailing list (Two-way)'),
      _MAILING_LIST_TYPE_BROADCAST => t('Broadcast only list (One-way)'),
    );
    $fieldset['list_options']['list_type'] = array(
      '#type' => 'radios',
      '#title' => t('List type'),
      '#description' => t('The type of Mailing List to create.'),
      '#options' => $options,
      '#default_value' => $defaults['list_type'],
      '#states' => array(
        // visible if we are attaching a list
        'visible' => array( 
          ':input[name="attach_list"]' => array('checked' => TRUE),
        ),
      ),
    );
    $fieldset['list_options']['user_defined_from'] = array(
      '#access' => FALSE, // hide for now, clients think we're spoofing
      '#type' => 'checkbox',
      '#title' => t('User-defined \'from\' in emails'),
      '#description' => t('Whether to include a custom from e-mail ' . 
          '(this is the e-mail address the e-mails will appear to be from)'),
      '#return_value' => 1, 
      '#default_value' => $defaults['user_defined_from'],
      '#states' => array(
        // visible if we are attaching a list
        'visible' => array( 
          ':input[name="attach_list"]' => array('checked' => TRUE),
        ),
      ),
    );
    $fieldset['list_options']['from_email'] = array(
      '#access' => FALSE, // hide for now, clients think we're spoofing
      '#type' => 'textfield',
      '#title' => t('From'),
      '#default_value' => $defaults['from_email'],
      '#states' => array(
        // visible if we are attaching alist
        // and user-defined from is checked
        'visible' => array(
          ':input[name="attach_list"]' => array('checked' => TRUE),
          ':input[name="user_defined_from"]' => array('checked' => TRUE),
        ),
        // required if we are attaching a list
        // and user-defined from is checked
        'required' => array(
          ':input[name="attach_list"]' => array('checked' => TRUE),
          ':input[name="user_defined_from"]' => array('checked' => TRUE),
        ),
      ),
    );
    $options = array(
      _BROADCAST_REPLY_TO_TYPE_POSTERS_EMAIL => t("Poster's e-mail address"),
      _BROADCAST_REPLY_TO_TYPE_DO_NOT_REPLY => t('Do not reply'),
      _BROADCAST_REPLY_TO_TYPE_USER_DEFINED => t('User-defined'),
    );
    $fieldset['list_options']['broadcast_reply_to_type'] = array(
      '#type' => 'radios',
      '#title' => t('Broadcast list reply-to type'),
      '#description' => t('How a broadcast list sets the reply-to e-mail ' . 
          '(this is the e-mail address recepients can reply to)'),
      '#options' => $options,
      '#default_value' => $defaults['broadcast_reply_to_type'],
      '#states' => array(
        // visible if and we are attaching a list 
        // and selected list type is broadcast
        'visible' => array( 
          ':input[name="attach_list"]' => array('checked' => TRUE),
          ':input[name="list_type"]' => array('value' => 1),
        ),     
      ),
    );
    $fieldset['list_options']['reply_to_email'] = array(
      '#type' => 'textfield',
      '#title' => t('Reply-to'),
      '#description' => t('The address that list recipients can reply to'),
      '#default_value' => $defaults['reply_to_email'],
      '#states' => array(
        // visible if we are attaching a list
        // list type is broadcast
        // and reply-to type is user-defined
        'visible' => array(
          ':input[name="attach_list"]' => array('checked' => TRUE),
          ':input[name="list_type"]' => array(
            'value' => _MAILING_LIST_TYPE_BROADCAST
          ),
          ':input[name="broadcast_reply_to_type"]' => array(
            'value' => _BROADCAST_REPLY_TO_TYPE_USER_DEFINED
          ),
        ),
        // required if we are attaching a list
        // and list type is broadcast
        // and reply-to type is user-defined
        'required' => array(
          ':input[name="attach_list"]' => array('checked' => TRUE),
          ':input[name="list_type"]' => array(
            'value' => _MAILING_LIST_TYPE_BROADCAST
          ),
          ':input[name="broadcast_reply_to_type"]' => array(
            'value' => _BROADCAST_REPLY_TO_TYPE_USER_DEFINED
          ),
        ),
      ),
    );
    $options = array(
      _STANDARD_REPLY_TO_TYPE_POSTERS_EMAIL => ("Poster's e-mail address"),
      _STANDARD_REPLY_TO_TYPE_MAILING_LIST => t("List's e-mail address"),
    );
    $fieldset['list_options']['standard_reply_to_type'] = array(
      '#type' => 'radios',
      '#title' => t('Standard list reply-to type'),
      '#description' => t('How a standard list sets the reply-to e-mail ' . 
          '(this is the e-mail address recepients can reply to)'),
      '#options' => $options,
      '#default_value' => $defaults['standard_reply_to_type'],
      '#states' => array(
        // visible if we are attaching a list
        // and list type is standard
        'visible' => array( 
          ':input[name="attach_list"]' => array('checked' => TRUE),
          ':input[name="list_type"]' => array(
            'value' => _MAILING_LIST_TYPE_STANDARD
          ),
        ),     
      ),
    );
    
    // Handle the alias ajax logic before we render the elements
    _aliases_ajax_logic($form, $form_state, $descriptors, $defaults);
    
    // We wrap the markup element in a container because a markup element
    // has no id and therefore #states doesn't work on it as expected
    $fieldset['list_options']['aliases_label'] = array(
      '#type' => 'container',
      '#states' => array(
        // visible if we are attaching a list
        // and selected list type is standard
        'visible' => array( 
          ':input[name="attach_list"]' => array('checked' => TRUE),
          ':input[name="list_type"]' => array(
            'value' => _MAILING_LIST_TYPE_STANDARD
          ),
        ),
      ), 
      'markup' => array(
        '#markup' => t('<label><p>Standard list e-mail aliases</p></label>'),
      ),
    );
    $fieldset['list_options']['aliases'] = array(
      '#type' => 'container',
      '#tree' => TRUE,
      '#prefix' => '<div id="aliases">', // div to script
      '#suffix' => '</div>',
      '#theme' => 'gb_maillist_aliases',
      '#states' => array(
        // visible if we are attaching a list
        // and selected list type is standard
        'visible' => array( 
          ':input[name="attach_list"]' => array('checked' => TRUE),
          ':input[name="list_type"]' => array(
            'value' => _MAILING_LIST_TYPE_STANDARD
          ),
        ),
      ), 
    );
    // embed the number of aliases into the form
    $fieldset['list_options']['aliases']['num_aliases'] = array(
      '#type' => 'value',
      '#value' => $form_state['storage']['num_aliases'],
    );
    $i = $form_state['storage']['num_aliases'];
    for ($i = 0; $i < $form_state['storage']['num_aliases']; $i++) {
      $fieldset['list_options']['aliases']["alias_$i"] = array(
        '#type' => 'textfield',
        '#title' => t('Alias'),
        //'#description' => t('Must be unique. ' .
        //    'Valid characters include lower case letters and underscores.'),
        '#maxlength' => _ALIAS_MAX_LENGTH,
        '#default_value' => isset($defaults["alias_{$i}"]) ? 
              $defaults["alias_{$i}"] : "",
      );
      $fieldset['list_options']['aliases']["del_alias_{$i}"] = array(
        '#type' => 'button',
        '#value' => t("Delete alias"),
        '#name' => "del_alias_{$i}",            // override op
        '#href' => '',
        '#executes_submit_callback' => FALSE,   // don't submit
        '#limit_validation_errors' => array(),  // no elements will be validated
        '#ajax' => array(
          // ajax to add 'textfield' elements
          'callback' => 'ajax_gb_maillist_delete_alias',
          'wrapper' => 'aliases',
          'method' => 'replaceWith',
          'prevent' => 'submit click mousedown',
        ),
      );
    }
    $fieldset['list_options']['add_alias'] = array(
      '#type' => 'button',
      '#value' => t('Add an alias'),
      '#name' => 'add_alias',
      '#href' => '',
      '#executes_submit_callback' => FALSE,   // don't submit
      '#limit_validation_errors' => array(),  // no elements will be validated
      '#states' => array(
        // visible if we are attaching a list
        // and selected list type is standard
        'visible' => array( 
          ':input[name="attach_list"]' => array('checked' => TRUE),
          ':input[name="list_type"]' => array(
            'value' => _MAILING_LIST_TYPE_STANDARD
          ),
        ),     
      ),
      '#ajax' => array(
        // ajax to add 'textfield' elements
        'callback' => 'ajax_gb_maillist_add_alias',
        'wrapper' => 'aliases',
        'method' => 'replaceWith',
        'prevent' => 'submit click mousedown',
      ),
    );
    
    // Elements to set which items are included in the list
    $fieldset['items'] = array(
      '#type' => 'fieldset',
      '#title' => t('List items'),
      //'#collapsible' => TRUE,
      //'#collapsed' => $collapsed,
      '#states' => array(
        // visible if we are attaching a list
        'visible' => array(
          ':input[name="attach_list"]' => array('checked' => TRUE),
        ),
      ),
    ); 
    foreach ($descriptors as $module => $classes) {
      foreach ($classes as $class_id => $class) {
        // serialize id for storage & parsing
        // SCID:CLASS
        $scid = 'scid:' . $class_id;
        $fieldset['items'][$scid] = array(
          '#type' => count($class['items']) < 20 ? 'checkboxes' : 'select',
          '#multiple' => TRUE,
          '#prefix' => '<div style="float: left; margin: 15px;">', 
          '#suffix' => '</div>',
          '#title' => $class['title'],
          '#description' => $class['description'],
          '#default_value' => isset($defaults[$scid]) ? 
              $defaults[$scid] : array(),
          '#options' => array(),
          '#states' => array(
            // visible if we are attaching a list
            'visible' => array( 
              ':input[name="attach_list"]' => array('checked' => TRUE),
            ),
          ),
        ); 
        foreach ($class['items'] as $item_id => $item) {
          // serialize id for storage & parsing
          // IID:MODULE:CLASS:ITEM
          $siid = 'iid:' . $module . ':' . $class_id . ':' . $item_id;
          $fieldset['items'][$scid]['#options'][$siid] = $item['title'];
        }
      } 
    }
  }
    
  /**
   * Implements hook_TYPE_alter()
   * 
   * @param array $data the data to be altered
   */
  function gb_maillist_mailing_list_descriptors_alter(&$data) {
    if (_TEST_LISTS === 1) {
      $data['gb_maillist'] = array(
        'storage_class_test' => array(
          'title' => 'Test Mail Clients',
          'description' => 'E-Mails for testing purposes',
          'items' => array(
            'list_yahoo' => array('title' => 'Yahoo'),
            'list_hotmail' => array('title' => 'Hotmail'),
            'list_gmail' => array('title' => 'Gmail'),
            'list_inbox' => array('title' => 'Inbox.com'),
            'list_mail' => array('title' => 'Mail.com'),
            'list_aim' => array('title' => 'AOL AIM Mail'),
            'list_icloud' => array('title' => 'iCloud'),
            'list_blacklist' => array('title' => 'Blacklist Test'),
            'list_all' => array('title' => 'All'),
          ),
        ),
      );
    }
  }

  /**
   * Implements hook_TYPE_alter()
   * 
   * @param array $data an array of emails
   */
  function gb_maillist_outgoing_email_addresses_alter(&$data) {
    if (_TEST_LISTS === 1) {
      // Blacklist (remove) emails ending with @blacklist.me
      $data = array_filter($data, function ($email) {
        $needle = '@blacklist.me';
        return (substr($email, -strlen($needle)) !== $needle);
      });
    }
  }
      
  /**
   * Implements hook_provide_email_addresses_for_class_items()
   * 
   * @param string $class_id the class the items belong to
   * @param array $item_ids a list of items (email list ids)
   * 
   * @return should return an array of emails as strings
   */
  function gb_maillist_provide_email_addresses_for_class_items($class_id, 
      $item_ids) {
    if (_TEST_LISTS === 1) {
      if ($class_id != 'storage_class_test') {
        return array();
      }
      
      $emails = array(
        'list_yahoo' => 'groupanizertest@yahoo.com',
        'list_hotmail' => 'groupanizertest@hotmail.com',
        'list_gmail' => 'bryan@groupanizer.com',
        'list_inbox' => 'groupanizertest@inbox.com',
        'list_mail' => 'groupanizert3st@mail.com',
        'list_aim' => 'groupanizertestaim@aim.com',
        'list_blacklist' => 'testing@blacklist.me',
        'list_icloud' => 'bp2626@icloud.com',
      );
      
      if (in_array('list_all', $item_ids)) {
        return array_values($emails);
      } else {
        return array_map(function ($item_id) use ($emails) {
          return $emails[$item_id];
        }, $item_ids);
      }
    }
    
    return array();
  }
      
  /**
   * Validation function for forum_node_form
   * 
   * @param array $form
   * @param array $form_state
   */
  function gb_maillist_forum_node_form_validate($form, &$form_state) {
    // Determine if the outgoing e-mail that will be generated is > max size
    $email_max_size = variable_get('gb_maillist_email_max_size');
    /** @todo stop arbitrarily reserving 4KB for the headers/css */
    $size = 4 * 1024;
    
    /** @todo don't assume strings aren't multi-byte / unicode */
    $size += strlen($form_state['values']['body'][LANGUAGE_NONE][0]['value']);
    foreach ($form_state['values']['field_attachment'][LANGUAGE_NONE] as 
        $attachment) {
      $file = file_load($attachment['fid']);
      if ($file) {
        $size += $file->filesize;
      }
    }
    
    if ($size > $email_max_size) {
      $in_mb = $email_max_sizes / 1024 / 1024;
      form_set_error('field_attachment', 
          t("The e-mail message is too large. Max allowed size: {$in_mb} MB"));
    }
  }
  
  /**
   * Validation function for comment_node_forum_form
   * 
   * @param array $form
   * @param array $form_state
   */
  function gb_maillist_form_comment_node_forum_form_validate($form, 
      &$form_state) {
    // Determine if the outgoing e-mail that will be generated is > max size
    $email_max_size = variable_get('gb_maillist_email_max_size');
    /** @todo stop arbitrarily reserving 4KB for the headers/css */
    $size = 4 * 1024;
    
    /** @todo don't assume strings aren't multi-byte / unicode */
    $size += strlen(
        $form_state['values']['comment_body'][LANGUAGE_NONE][0]['value']);
    foreach ($form_state['values']['field_attachment'][LANGUAGE_NONE] as 
        $attachment) {
      $file = file_load($attachment['fid']);
      if ($file) {
        $size += $file->filesize;
      }
    }
    
    if ($size > $email_max_size) {
      $in_mb = $email_max_sizes / 1024 / 1024;
      form_set_error('field_attachment', 
          t("The e-mail message is too large. Max allowed size: {$in_mb} MB"));
    }
  }
      
  /**
   * Validation function for forum form
   *
   * @param array $form
   * @param array $form_state 
   */
  function gb_maillist_forum_form_validate($form, &$form_state) {
    if ($form_state['values']['attach_list'] !== 1) {
      return; // Not including a mailing list
    }
    
    if ($form_state['triggering_element']['#parents'][0] === 'add_alias') {
      return; // Brought here by the add_alias AJAX event
    }
    
    /** 
     * The internal drupal form validator can't seem to handle
     * '#required' changes by jQuery for the forum_form when the elements
     * are in our field set. So, we'll validate them manually. We need to make
     * sure they are valid e-mails as well.
     * 
     * We also need to check if a mailing list item was selected.
     * 
     * We also need to check if the aliases aren't duplicates, aren't empty
     * and don't contain invalid characters.
     * 
     * @todo bug report or determine if the #states code isn't correct
     */
    $values = &$form_state['values'];
    $list_options = &$form['mailing_list_setup']['list_options'];
     
    if ($values['broadcast_reply_to_type'] == 
        _BROADCAST_REPLY_TO_TYPE_USER_DEFINED) {
      if (empty($values['reply_to_email'])) {
        $title = $list_options['reply_to_email']['#title'];
        form_set_error('reply_to_email', t("{$title} is required."));
      } elseif (!filter_var($values['reply_to_email'], FILTER_VALIDATE_EMAIL)) {
        $email = $values['reply_to_email'];
        form_set_error('reply_to_email', 
            t("'{$email}' is not a valid e-mail address."));
      }
    }
    
    if ($values['user_defined_from'] === 1) {
      if (empty($values['from_email'])) {
        $title = $list_options['from_email']['#title'];
        form_set_error('from_email', t("{$title} is required."));
      } elseif (!filter_var($values['from_email'], FILTER_VALIDATE_EMAIL)) {
        $email = $values['from_email'];
        form_set_error('from_email', 
            t("'{$email}' is not a valid e-mail address."));
      }
    }
    
    if ($values['list_type'] == _MAILING_LIST_TYPE_STANDARD) {
      if ($form_state['storage']['num_aliases'] === 0) {
        form_set_error('aliases', 
          t('At least one alias is required for standard lists'));
      }
    
      $aliases = _extract_values_with_keys_that_match_pattern(
          $form_state['values']['aliases'], '/^alias_[0-5]$/');
      $aliases_unique = array_unique($aliases); // filter duplicates
      // Get the keys that are in $aliases but not in $aliases_unique. These
      // are aliases with duplicate values.
      $duplicates = array_diff_key($aliases, $aliases_unique);
      foreach ($duplicates as $key => $value) {
        form_set_error("aliases][{$key}", t('Aliases must be unique.'));
      }
      foreach ($aliases_unique as $key => $value) {
        if (empty($value)) {
          form_set_error("aliases][{$key}", t('Aliases cannot be empty.'));
        } elseif (!preg_match('/^[a-z_]+$/', $value)) {
          form_set_error("aliases][{$key}", 
              t("Alias '{$value}' contains illegal characters."));
              $form_state['rebuild'] = TRUE;
        } elseif (_check_for_alias_record($value, isset($values['tid']) ? 
            $values['tid'] : NULL)) {
          form_set_error("aliases][{$key}", 
              t("Alias '{$value}' is already in use by another mailing list."));
        }
      }
    }
    
    $a_list_item_is_checked = FALSE;

    $list_classes = _extract_values_with_keys_that_match_pattern(
        $form_state['values'], '/^scid:.*$/');
    foreach ($list_classes as $class) {
      foreach ($class as $item_key => $item_value) {
        if ($item_key === $item_value) { // checked if value === key
          $a_list_item_is_checked = TRUE;
          break 2; // break out of inner & outter loop         
        }
      }
    }

    if (!$a_list_item_is_checked) {
      form_set_error('items', t('At least one mailing list item is required.'));
    }
  }

  /**
   * Submit function for forum confirm delete form
   * 
   * @param array $form
   * @param array $form_state 
   */
  function gb_maillist_forum_confirm_delete_submit($form, &$form_state) {
    // Is a user logged in and authenticated?
    $user = g3core_get_user();
    if (!(isset($user->uid)) || $user->uid === 0) {
      drupal_access_denied();
    }
    
    // Do we have the right form id?
    if ($form_state['build_info']['form_id'] != 'forum_confirm_delete') {
      return;
    }
    
    $result = _delete_all_list_records_for_tid($form_state['values']['tid']);
    if (!$result) {
      drupal_set_message(t('Failed to query the database'), 'error');
      $form_state['rebuild'] = TRUE;
    }
  }
  
  /**
   * Submit function for forum form
   * 
   * @param array $form
   * @param array $form_state 
   */
  function gb_maillist_forum_form_submit($form, &$form_state) {
    // Is a user logged in and authenticated?
    $user = g3core_get_user();
    if (!(isset($user->uid)) || $user->uid === 0) {
      drupal_access_denied();
    }
    
    // Do we have the right form id?
    if ($form_state['build_info']['form_id'] != 'forum_form_forum') {
      return;
    }
    
    $values = &$form_state['values'];
    $attach = $values['attach_list'];
    $tid = $values['tid'];
    
    if (!$attach) {
      // We are not attaching a list, so, delete any previously associated
      // metadata and items in the database
      $result = _delete_all_list_records_for_tid($tid);
    } else {
      // If the user has unselected user_defined_from we don't want to write
      // the from email because that's all we store in the database. If it's
      // there we will assume user_defined_from is 1 later.
      if ($values['user_defined_from'] !== 1) {
        $values['from_email'] = NULL;
      }
      // We are attaching a list
      // build and write our query for gb_maillist_metadata
      // db_merge will handle update & insert
      $result = _build_and_insert_list_records_for_tid($tid, $values);
    }
    if (!$result) {
      drupal_set_message(t('Failed to query the database'), 'error');
      $form_state['rebuild'] = TRUE;
    }
  }

  /**
   * Implements hook_form_FORM_ID_alter()
   * 
   * @param array $form nested array of form elements that comprise the form
   * @param array $form_state an array containing the current state of the form
   * @param string $form_id string representing the name of the form itself
   */
  function gb_maillist_form_forum_form_forum_alter(&$form, 
      &$form_state, $form_id) {
    $descriptors = _fetch_mailing_list_descriptors();
    // Typically NULL for new forms, fill to current values in db on edit
    $defaults = _fetch_forum_form_default_values(
        isset($form['tid']) ? $form['tid']['#value'] : NULL);
    _insert_mailing_list_elements($form, $form_state, $descriptors, $defaults);
    
    $form['#submit'][] = 'gb_maillist_forum_form_submit';
    $form['#validate'][] = 'gb_maillist_forum_form_validate';
  }

  /**
   * Implements hook_form_FORM_ID_alter()
   * 
   * @param array $form nested array of form elements that comprise the form
   * @param array $form_state an array containing the current state of the form
   * @param string $form_id string representing the name of the form itself
   */
  function gb_maillist_form_forum_confirm_delete_alter(&$form, 
      &$form_state, $form_id) {
     // Insert our submit handler for deleting of forums
     $form['#submit'][] = 'gb_maillist_forum_confirm_delete_submit';
  }
      
  /**
   * Implements hook_form_FORM_ID_alter()
   * 
   * @param array $form nested array of form elements that comprise the form
   * @param array $form_state an array containing the current state of the form
   * @param string $form_id string representing the name of the form itself
   */
  function gb_maillist_form_forum_node_form_alter(&$form, 
      &$form_state, $form_id) {
    // Hide the element that lets the user choose which forum to post to
    // IF a forum has already been chosen via the URL.
    // Don't hide it if it's through Content -> Add Content
    $requested_forum_id = arg(3);
    if (is_numeric($requested_forum_id)) {
      $form['taxonomy_forums'][LANGUAGE_NONE]['#access'] = FALSE;
    }
    
    $form['#validate'][] = 'gb_maillist_forum_node_form_validate';
  }
      
  /**
   * Implements hook_form_FORM_ID_alter()
   * 
   * @param array $form nested array of form elements that comprise the form
   * @param array $form_state an array containing the current state of the form
   * @param string $form_id string representing the name of the form itself
   */
  function gb_maillist_form_comment_node_forum_form_alter(&$form, &$form_state, 
      $form_id) {
    $form['#validate'][] = 'gb_maillist_form_comment_node_forum_form_validate'; 
  }   
      
  /**
   * Implemenets hook_menu()
   */
  function gb_maillist_menu() {
    return array(
      'g/comm/maillist/view/%' => array(
        'title' => t('View the e-mail(s) assocated with a mailing list'),
        'page callback' => 'gb_maillist_view_list_page',
        'page arguments' => array(4), // tid as argument
        'access arguments' => array('administer forums'),
        'file' => 'gb_maillist.pages.inc',
        'type' => MENU_CALLBACK,
      ),
      'g/comm/maillist/export/%' => array(
        'title' => t('Export a mailing list to CSV'),
        'page callback' => 'gb_maillist_export_list_page',
        'page arguments' => array(4), // tid as argument
        'access arguments' => array('administer forums'),
        'file' => 'gb_maillist.pages.inc',
        'type' => MENU_CALLBACK,
      ),
      'g/comm/maillist/unsubscribe/%/%' => array(
        'title' => t('Unsubscribe from a mailing list'),
        'page callback' => 'gb_maillist_unsubscribe_from_list_page',
        'page arguments' => array(4, 5), // nid & email as arguments
        'access arguments' => array(TRUE),
        'file' => 'gb_maillist.pages.inc',
        'type' => MENU_CALLBACK,
      ),
      'g/comm/maillist/board' => array(
        'title' => t('Discussion Boards'),
        'page callback' => 'gb_maillist_forums_page',
        'page arguments' => array(),
        'access arguments' => array('view forums'),
        'file' => 'gb_maillist.pages.inc',
        'type' => MENU_NORMAL_ITEM,
      ),
    );
  }
 
 /**
  * Implements hook_menu_alter
  */
  function gb_maillist_menu_alter(&$items) {
    // Disable the forum page
    $items['forum']['access callback'] = FALSE;
  }

  /**
   * Implements hook_preprocess_breadcrumb
   */
  function gb_maillist_preprocess_breadcrumb(&$variables) {
    // Adjust forum breadcrumbs
    if (isset($variables['breadcrumb'])) {
      if (isset($variables['breadcrumb'][1])) {
        $breadcrumb = $variables['breadcrumb'][1];
        if (preg_match("/^.*Forums.*$/", $breadcrumb)) {
          $rightmost = array_slice($variables['breadcrumb'], 2);
          
          $variables['breadcrumb'] = array();
          $variables['breadcrumb'][0] = '<a href="/" id="&lt;front&gt;">Home</a>';
          $variables['breadcrumb'][1] = '<a href="/g/comm" id="g-comm">Communicate</a>';
          $variables['breadcrumb'][2] = '<a href="/g/comm/maillist/board" id="board">Discussion Boards</a>';
          
          foreach ($rightmost as $breadcrumb) {
            $variables['breadcrumb'][] = $breadcrumb;
          }
        }
      }
    }
  }
      
  /**
   * Implements hook_admin_paths_alter()
   */
  function gb_maillist_admin_paths_alter(&$paths) {
    $paths['g/comm/maillist/view/%'] = TRUE;
    $paths['g/comm/maillist/export/%'] = TRUE;
    $paths['g/comm/maillist/unsubscribe/%/%'] = TRUE;
  }
  
  /**
   * Implements hook_admin_paths()
   */
  function gb_maillist_admin_paths() {
    return array(
      'g/comm/maillist/view/%' => TRUE,
      'g/comm/maillist/export/%' => TRUE,
      'g/comm/maillist/unsubscribe/%/%' => TRUE,
    );
  }

  /** 
   * Implements hook_theme() 
   */
  function gb_maillist_theme($existing, $type, $theme, $path) {
    return array(
      'gb_maillist_aliases' => array(
        'render element' => 'aliases',
      ),
    );
  }
  
  /**
   * Implements hook_node_insert()
   */
  function gb_maillist_node_insert($node) {
    // Drush incoming mail command has to save the node twice
    // so, ignore inserts from the cli
    if (php_sapi_name() != 'cli') {
      _node_update_and_insert($node);
    }
  }
  
  /**
   * Implements hook_node_update()
   */
  function gb_maillist_node_update($node) {
    _node_update_and_insert($node);
  }
  
  /**
   * Implements hook_comment_insert()
   */
  function gb_maillist_comment_insert($comment) {
    _comment_update_and_insert($comment);
  }
  
  /**
   * Implements hook_comment_update()
   */
  function gb_maillist_comment_update($comment) {
    _comment_update_and_insert($comment);
  }
  
  /**
   * Implements hook_permission()
   */
  function gb_maillist_permission() {
    return array(
      'view forums' => array(
        'title' => t('View the forums'),
        'description' => t('This is a top-level permission that allows users' .
            ' to view the forums'),
      ),
    );
  }
  
  /**
   * Implements hook_notification()
   */
  function gb_maillist_notification() {
    return array(
      'rejection' => t('Rejection'),
      'bounce' => t('Bounce'),
    );
  }
  