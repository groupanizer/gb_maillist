<?php

  module_load_include('inc', 'gb_maillist', 'gb_maillist.gfeature');  
  module_load_include('inc', 'gb_maillist', 'gb_maillist.constants');
  module_load_include('inc', 'gb_maillist', 'gb_maillist.queries');
  module_load_include('inc', 'gb_maillist', 'gb_maillist.api');
  
  function _is_forum_topic($node) {
    if ($node->type !== 'forum') {
      return FALSE;
    }
    
    // Is this coming from the forum post topic form that we've hooked?
    if ($node->form_id !== 'forum_node_form') {
      return FALSE;
    }
    
    return TRUE;
  }
  
  function _is_forum_comment($comment) {
    if ($comment->node_type !== 'comment_node_forum') {
      return FALSE;
    }
    
    // Is this coming from the forum post comment form?
    if ($comment->form_id !== 'comment_node_forum_form') {
      return FALSE;
    }
    
    return TRUE;
  }
  
  function _get_forum_tid_from_topic_node($node) {
    // Do we have an attached forum taxonomy?
    if (!isset($node->taxonomy_forums)) {
      return FALSE;
    }
    
    return $node->taxonomy_forums[LANGUAGE_NONE][0]['tid'];
  }
  
  /*
   * Fetch a list of outgoing email addresses from other modules
   * and sanitize the list in various ways.
   */
  function _fetch_outgoing_email_addresses($tid, $items) {
    $result = array();
    
    $lists = array();
    // Aggregate the items by module and storage class id
    foreach ($items as $item) {
      $module = $item['module'];
      $class_id = $item['class'];
      $item_id = $item['item'];
      
      $lists[$module][$class_id][] = $item_id;
    }
    
    // Get the e-mails from the providing modules
    foreach ($lists as $module => $classes) {
      foreach ($classes as $class_id => $items)
      // Get the emails for the item id
      $addresses = call_user_func($module . 
          '_provide_email_addresses_for_class_items', $class_id, $items);
      if (!empty($addresses)) {
        $result = array_merge($result, $addresses);
      }
    }
    
    // Filter out the duplicates
    $result = array_unique($result);
    
    $blacklisted = _fetch_blacklisted_emails_for_tid($tid);
    
    // Remove any blacklisted e-mails
    $result = array_diff($result, $blacklisted);
    
    // Give other modules a chance to alter the emails
    drupal_alter('outgoing_email_addresses', $result);
    
    return $result;
  }
  
  /* 
   * Retrieve the mailing list descriptors from other modules
   */
  function _fetch_mailing_list_descriptors() {
    $descriptors = array();
    // We have no default or provided descriptors
    // so let the other modules alter the descriptors
    drupal_alter('mailing_list_descriptors', $descriptors);
    
    foreach (array_keys($descriptors) as $key) {
      if (strlen($key) > DRUPAL_EXTENSION_NAME_MAX_LENGTH) {
        throw new Exception('Module name length exceeds ' . 
            'DRUPAL_EXTENSION_NAME_MAX_LENGTH');
      }
    } 
    
    return $descriptors;
  }
  
  /** 
   * @todo PROPER BOUNCES
   * @todo ALIASES
   */
  function _dispatch_emails_for_post($nid, $metadata, $subject, $body, 
      $update, $plain, $attachment_fid = NULL) {
    $tid = $metadata['tid'];
    $list_type = $metadata['list_type'];
    $reply_to_type = $metadata['reply_to_type'];
    $reply_to_email = $metadata['reply_to_email'];
    
    $items = _fetch_list_items_for_tid($tid);
    if (empty($items)) {
      // We should always have items attached to a mailing list
      drupal_set_message(t('Mailing list has no attached lists'), 'error');
      return;
    }
    
    $addresses = _fetch_outgoing_email_addresses($tid, $items);
    if (empty($addresses)) { 
      drupal_set_message(t('Failed to retrieve any emails for list'), 'error');
      return;
    }
    
    global $base_url;
    global $user;
    
    // Get the current site's domain name
    $host = parse_url($base_url, PHP_URL_HOST);
    $domain = preg_replace('/^www\./', '', $host);
    
    if ($reply_to_type == _REPLY_TO_TYPE_DO_NOT_REPLY) {
        $reply_to = "DO NOT REPLY <do_not_reply@{$domain}>";
    } elseif ($reply_to_type == _REPLY_TO_TYPE_USE_POSTERS_EMAIL) {
       $reply_to = "{$user->name} <{$user->mail}>";
    } elseif ($reply_to_type == _REPLY_TO_TYPE_USER_DEFINED) {
        $reply_to = $reply_to_email;
    } else {  // _REPLY_TO_TYPE_MAILING_LIST
        //drupal_set_message(t('Unknown reply-to type'), 'error');
        //return;
        $reply_to = 'TODO';
    }
    
    // Set From to the Reply-To or the user-defined variable
    $from = is_null($metadata['from_email']) ? 
        $reply_to : $metadata['from_email'];
    
    $sender = 'mailer@' . $domain;
    $bounces = 'bounces@' . $domain;
    //$bounces = 'support@groupanizer.com';
    
    // Read attachment details
    if (!is_null($attachment_fid)) {
      $file = file_load($attachment_fid);
      $filename = $file->uri;
      $filemime = $file->filemime;
    }
    
    $dispatcher = new EmailDispatcher($sender, $bounces);
    
    // Construct an array of batch operations
    $operations = array();
    
    foreach ($addresses as $address) {
      $email = new EmailMimeEmail;
      $email->set_paths($address, $from, $reply_to);
      $email->set_subject($subject);
      $email->set_main_body($body, $plain);
      if (!$plain) {
        $alt_body = 'To view this e-mail you need an HTML compatible client.';
        $email->set_alt_body($alt_body);
      }
      if (!is_null($attachment_fid)) {
        $email->add_attachment($filename, $filemime);
      }
      // Handle unsubscribe for broadcast lists
      if ($list_type == _MAILING_LIST_TYPE_BROADCAST) {
        $mailto = "<mailto:unsubscribe-{$tid}@{$domain}>";
        $encoded = urlencode($address);
        $url = "{$base_url}/mailing-list/unsubscribe/{$tid}/{$encoded}";
        
        $email->add_header('List-Unsubscribe', $mailto);
        $email->add_additional_body(
            "<footer><a href=\"{$url}\">Unsubscribe</a></footer>");
      }
    
      $operations[] = array('_dispatch_email', array($dispatcher, $email));
    }
    
    // Create a batch operation to send the e-mails
    $batch = array(
      'title' => t('Dispatching e-mail'),
      'operations' => $operations,
      'finished' => '_dispatch_email_finished',
      'file' => drupal_get_path('module', 'gb_maillist') . 
          '/gb_maillist.batch.inc',
    );
    
    batch_set($batch);

    // _MAILING_LIST_TYPE_ STANDARD|BROADCAST
  }

  function _node_update_and_insert($node) {
    if (!_is_forum_topic($node)) {
      return;
    }
    
    $tid = _get_forum_tid_from_topic_node($node);
    if (!$tid) {
      drupal_set_message(t('Forum node has no attached tid'), 'error');
      return;
    }
    
    $metadata = _fetch_list_metadata_for_tid($tid);
    if (!$metadata) {
      return; // There is no mailing list attached to this forum
    }
    
    dpm($node);
    return;
    
    $update = !$node->is_new;
    $body = $node->body[LANGUAGE_NONE][0]['value'];
    $plain = ($node->body[LANGUAGE_NONE][0]['format'] === 'plain_text');
    $subject = $node->title;
    $fid = isset($node->field_attachment[LANGUAGE_NONE][0]['fid']) ?
        $node->field_attachment[LANGUAGE_NONE][0]['fid'] : NULL;
    _dispatch_emails_for_post($node->nid, $metadata, $subject, $body, 
        $update, $plain, $fid); 
  }

  /**
   * @todo report / research bug (inconsistency)
   * entity type node has is_new property
   * entity type comment has new property
   */
  function _comment_update_and_insert($comment) {
    if (!_is_forum_comment($comment)) {
      return;
    }
    
    // Load the topic node to get the parent tid
    $node = node_load($comment->nid);
    $tid = _get_forum_tid_from_topic_node($node);
    if (!$tid) {
      drupal_set_message(t('Forum node has no attached tid'), 'error');
      return;
    }
    
    $metadata = _fetch_list_metadata_for_tid($tid);
    if (!$metadata) {
      return; // There is no mailing list attached to this forum
    }
    
    // Comment doesn't have the property is_new like node.
    // However, there is a 'new' property (integer) set to 0 for update
    // However, the property doesn't exist on insert?
    $update = FALSE;
    if (property_exists($comment, 'new')) {
      if ($comment->new === 0) {
        $update = TRUE;
      }
    }
    
    $comment_body = $comment->comment_body[LANGUAGE_NONE][0];
    $plain = ($comment_body['format'] === 'plain_text');
    $body = $comment_body['value'];
    $subject = $comment->subject;
    $fid = isset($comment->field_attachment[LANGUAGE_NONE][0]['fid']) ?
        $comment->field_attachment[LANGUAGE_NONE][0]['fid'] : NULL;  
    _dispatch_emails_for_post($node->nid, $metadata, $subject, $body, 
        $update, $plain, $fid);
  }

  function _extract_values_with_keys_that_match_pattern($values, $pattern) {
    $result = array();
    
    foreach ($values as $key => $value) {
      if (is_string($key)) {
        if (preg_match($pattern, $key)) {
          $result[$key] = $value;
        }
      }
    }
    
    return $result;
  }

  function _fetch_forum_form_default_values($tid) {
    $defaults = array(
        'attach_list' => 0,
        'list_type' => _MAILING_LIST_TYPE_BROADCAST,
        'reply_to_type' => _REPLY_TO_TYPE_DO_NOT_REPLY,
        'reply_to_email' => NULL,
        'from_email' => NULL,
        'user_defined_from' => NULL,
        'num_aliases' => 0,
     );
    
    if (!is_null($tid)) {
      $metadata = _fetch_list_metadata_for_tid($tid);
      if (!$metadata) { // No attached metadata?
        return $defaults;
      }
      
      $current = array(
        'attach_list' => 1,
        'list_type' => $metadata['list_type'],
        'reply_to_type' => $metadata['reply_to_type'],
        'reply_to_email' => $metadata['reply_to_email'],
        'from_email' => $metadata['from_email'],
        'user_defined_from' => empty($metadata['from_email']) ? 0 : 1,
      );
      
      $items = _fetch_list_items_for_tid($tid);
      if (empty($items)) {
        // We should always have items attached to a mailing list
        drupal_set_message(t('Mailing list has no attached lists'), 'error');
        return;
      }
      
      foreach ($items as $item) {
        // scid:<storage_class_id>
        $scid = 'scid:' . $item['class'];
        // iid:<module>:<storage_class_id>:<item_id>
        $siid = 'iid:' . $item['module'] . ':' . 
            $item['class'] . ':' . $item['item'];
        
        $current[$scid][] = $siid;
      }
      
      $aliases = _fetch_list_aliases_for_tid($tid);
      if (empty($aliases)) {
        $current['num_aliases'] = 0;
      } else {
        $n = count($aliases);
        $current['num_aliases'] = $n;
        while ($n-- > 0) {
          $current["alias_{$n}"] = $aliases[$n]['alias'];
        } 
      }

      return $current;
    }

    return $defaults;
  }

  /** Callback to replace the 'aliases' elements */
  function ajax_gb_maillist_add_alias($form, $form_state) {
    return $form['mailing_list_setup']['list_options']['aliases'];
  }
  
  /** Callback to replace the 'aliases' element */
  function ajax_gb_maillist_delete_alias($form, $form_state) {
    return $form['mailing_list_setup']['list_options']['aliases'];
  }
  
  /** Callback function to theme the 'aliases' */
  function theme_gb_maillist_aliases($container) {
    $elements = $container['aliases'];
    
    if (isset($elements['num_aliases']) && $elements['num_aliases'] > 0) {
      $variables = array(
        'header' => array(t('Aliases'), t('Delete')),
        'empty' => t("No aliases."),
        'rows' => array(),
        'attributes' => array(),
        'caption' => t("Aliases used to e-mail this list." .
            " Format: <em>alias</em>@domain" . 
            " (don't include the domain). Valid characters are lowercase" .
            " letters and underscores."),
        'colgroups' => array(),
        'sticky' => FALSE,
      );
      
      $num_aliases = $elements['num_aliases']['#value'];
      for ($i = 0; $i < $num_aliases; $i++) {
        $variables['rows'][$i][] = drupal_render($elements["alias_{$i}"]);
        $variables['rows'][$i][] = drupal_render($elements["del_alias_{$i}"]);
      }
      
      return theme_table($variables);
    }
  }
  
  /** Handles the logic for adding and removing aliases */
  function _aliases_ajax_logic(&$form, &$form_state, 
      $descriptors, $defaults) {
    // Set the number of aliases to 0 on form creation
    if (!isset($form_state['storage']['num_aliases'])) {
      $form_state['storage']['num_aliases'] = $defaults['num_aliases'];
    }
    
    // If we were brought here by the AJAX event to an alias than the number of
    // aliases has increased or decreased
    if (isset($form_state['triggering_element'])) {
      $matches = array();
      $name = $form_state['triggering_element']['#name'];
      if ($name === 'add_alias') { // brought here by add_alias
        if ($form_state['storage']['num_aliases'] < 5) { // cap of 5 aliases
          $form_state['storage']['num_aliases'] += 1;
          //dpm('+= 1;');
        }
      } elseif (preg_match('/^del_alias_([0-5])$/', $name, $matches)) {
        $form_state['storage']['num_aliases'] -= 1;
        
        $new_num_aliases = $form_state['storage']['num_aliases'];
        $index_to_delete = $matches[1];
        
        // We need to rebuild & restructure the input array to preserve
        // the current input values
        $input = $form_state['input']['aliases'];
        unset($input["alias_{$index_to_delete}"]); // delete alias
        $values = array_values($input);  
        $keys = array();
        for ($i = 0; $i < $new_num_aliases; $i++) {
          $keys[] = "alias_{$i}";
        }
        // Assign the new input values
        $form_state['input']['aliases'] = array_combine($keys, $values);  
      }
    }
  }

  function gb_maillist_mimemail_incoming($mail) {
    dpm($mail);
  }

  /**
   * Insert our elements into the forum form
   * @todo make collapsable
   */
  function _insert_mailing_list_elements(&$form, &$form_state, 
      $descriptors, $defaults) {
    $collapsed = ($defaults['attach_list'] === 0) ? TRUE : FALSE;
    
    /*
    $email = file_get_contents(drupal_get_path('module', 'gb_maillist') . '/email');
    module_load_include('inc', 'mimemail', 'includes/mimemail.incoming');
    mimemail_incoming($email);
    */
    
    
    // Create the mailing list fieldset
    $form['mailing_list_setup'] = array(
      '#type' => 'fieldset',
      '#title' => 'Mailing list',
      '#collapsible' => TRUE,
    );
    $fieldset = &$form['mailing_list_setup'];
    
    // Checkbox whether or not to attach a mailing list
    $fieldset['attach_list'] = array(
      '#type' => 'checkbox',
      '#title' => t('Attach Mailing list'),
      '#decription' => t('Whether to include a mailing list'),
      '#return_value' => 1, 
      '#default_value' => $defaults['attach_list'], 
    );
    
    // Group of elements to set the list options 
    $fieldset['list_options'] = array(
      '#type' => 'fieldset',
      '#title' => t('List options'),
      '#collapsible' => TRUE,
      '#collapsed' => $collapsed,
      '#states' => array(
        // collapsed if we aren't attaching a list
        'collapsed' => array(
          ':input[name="attach_list"]' => array('checked' => FALSE),
        ),
      ),
    );
    $options = array(
      _MAILING_LIST_TYPE_STANDARD => t('Standard mailing list (Two-way)'),
      _MAILING_LIST_TYPE_BROADCAST => t('Broadcast only list (One-way)'),
    );
    $fieldset['list_options']['list_type'] = array(
      '#type' => 'radios',
      '#title' => t('List type'),
      '#description' => t('The type of Mailing List to create.'),
      '#options' => $options,
      '#default_value' => $defaults['list_type'],
      '#states' => array(
        // enabled if we are attaching a list
        'enabled' => array( 
          ':input[name="attach_list"]' => array('checked' => TRUE),
        ),
      ),
    );
    $fieldset['list_options']['user_defined_from'] = array(
      '#type' => 'checkbox',
      '#title' => t('User-defined \'from\' in emails'),
      '#decription' => t('Whether to include a custom from email'),
      '#return_value' => 1, 
      '#default_value' => $defaults['user_defined_from'],
      '#states' => array(
        // enabled if we are attaching a list
        'enabled' => array( 
          ':input[name="attach_list"]' => array('checked' => TRUE),
        ),
      ),
    );
    $fieldset['list_options']['from_email'] = array(
      '#type' => 'textfield',
      '#title' => t('From'),
      '#default_value' => $defaults['from_email'],
      '#states' => array(
        // visible if user-defined from is checked
        'visible' => array(
          ':input[name="user_defined_from"]' => array('checked' => TRUE),
        ),
        // required if user-defined from is checked and we are attaching a list
        'required' => array(
          ':input[name="user_defined_from"]' => array('checked' => TRUE),
          ':input[name="attach_list"]' => array('checked' => TRUE),
        ),
        // enabled if we are attaching a list
        'enabled' => array(
          ':input[name="attach_list"]' => array('checked' => TRUE),
        ),
      ),
    );    
    $options = array(
      _REPLY_TO_TYPE_DO_NOT_REPLY => t('Do not reply'),
      _REPLY_TO_TYPE_USE_POSTERS_EMAIL => t('Use poster\'s e-mail'),
      _REPLY_TO_TYPE_USER_DEFINED => t('User-defined'),
    );
    $fieldset['list_options']['reply_to_type'] = array(
      '#type' => 'radios',
      '#title' => t('Broadcast list reply-to'),
      '#description' => t('How a broadcast list sets reply-to'),
      '#options' => $options,
      '#default_value' => $defaults['reply_to_type'],
      '#states' => array(
        // enabled if selected list type is broadcast
        // and we are attaching a list
        'enabled' => array( 
          ':input[name="list_type"]' => array('value' => 1),
          ':input[name="attach_list"]' => array('checked' => TRUE),
        ),     
      ),
    );
    $fieldset['list_options']['reply_to_email'] = array(
      '#type' => 'textfield',
      '#title' => t('Reply-to'),
      '#description' => t('The email that list recipients can reply to'),
      '#default_value' => $defaults['reply_to_email'],
      '#states' => array(
        // visible if reply-to type is user-defined
        'visible' => array(
          ':input[name="reply_to_type"]' => array(
            'value' => _REPLY_TO_TYPE_USER_DEFINED
          ),
        ),
        // required if reply-to type is user-defined and we are attaching a list
        'required' => array(
          ':input[name="reply_to_type"]' => array(
            'value' => _REPLY_TO_TYPE_USER_DEFINED
          ),
          ':input[name="attach_list"]' => array('checked' => TRUE),
        ),
        // enabled if we are attaching a list
        'enabled' => array(
          ':input[name="attach_list"]' => array('checked' => TRUE),
        ),
      ),
    );
    // Handle the alias ajax logic before we render the elements
    _aliases_ajax_logic($form, $form_state, $descriptors, $defaults);
    
    $fieldset['list_options']['aliases_label'] = array(
      '#type' => 'markup',
      '#markup' => t('<label>Standard list e-mail aliases</label>'),
    );
 
    
    $fieldset['list_options']['aliases'] = array(
      '#type' => 'container',
      '#tree' => TRUE,
      '#prefix' => '<div id="aliases">', // new line & div to script
      '#suffix' => '</div>',
      '#theme' => 'gb_maillist_aliases',
    );
 
    // embed the number of aliases into the form
    $fieldset['list_options']['aliases']['num_aliases'] = array(
      '#type' => 'value',
      '#value' => $form_state['storage']['num_aliases'],
    );
    
    $i = $form_state['storage']['num_aliases'];
    for ($i = 0; $i < $form_state['storage']['num_aliases']; $i++) {
      $fieldset['list_options']['aliases']["alias_$i"] = array(
        '#type' => 'textfield',
        '#title' => t('Alias'),
        //'#description' => t('Must be unique. ' .
        //    'Valid characters include lower case letters and underscores.'),
        '#maxlength' => _ALIAS_MAX_LENGTH,
        '#default_value' => isset($defaults["alias_{$i}"]) ? 
              $defaults["alias_{$i}"] : "",
        '#states' => array(
          // enabled if selected list type is standard
          // and we are attaching a list
          'enabled' => array( 
            ':input[name="list_type"]' => array('value' => 0),
            ':input[name="attach_list"]' => array('checked' => TRUE),
          ),     
        ),
      );
      $fieldset['list_options']['aliases']["del_alias_{$i}"] = array(
        '#type' => 'button',
        '#value' => t("Delete alias"),
        '#name' => "del_alias_{$i}",            // override op
        '#href' => '',
        '#executes_submit_callback' => FALSE,   // don't submit
        '#limit_validation_errors' => array(),  // no elements will be validated
        '#states' => array(
          // enabled if selected list type is standard
          // and we are attaching a list
          'enabled' => array( 
            ':input[name="list_type"]' => array('value' => 0),
            ':input[name="attach_list"]' => array('checked' => TRUE),
          ),     
        ),
        '#ajax' => array(
          // ajax to add 'textfield' elements
          'callback' => 'ajax_gb_maillist_delete_alias',
          'wrapper' => 'aliases',
          'method' => 'replaceWith',
          'prevent' => 'submit click mousedown',
        ),
      );
    }
    $fieldset['list_options']['add_alias'] = array(
      '#type' => 'button',
      '#value' => t('Add an alias'),
      '#name' => 'add_alias',
      '#href' => '',
      '#executes_submit_callback' => FALSE,   // don't submit
      '#limit_validation_errors' => array(),  // no elements will be validated
      '#states' => array(
        // enabled if selected list type is standard
        // and we are attaching a list
        'enabled' => array( 
          ':input[name="list_type"]' => array('value' => 0),
          ':input[name="attach_list"]' => array('checked' => TRUE),
        ),     
      ),
      '#ajax' => array(
        // ajax to add 'textfield' elements
        'callback' => 'ajax_gb_maillist_add_alias',
        'wrapper' => 'aliases',
        'method' => 'replaceWith',
        'prevent' => 'submit click mousedown',
      ),
    );
    
    // Elements to set which items are included in the list
    $fieldset['items'] = array(
      '#type' => 'fieldset',
      '#title' => t('List items'),
      '#collapsible' => TRUE,
      '#collapsed' => $collapsed,
      '#states' => array(
        // collapsed if we aren't attaching a list
        'collapsed' => array(
          ':input[name="attach_list"]' => array('checked' => FALSE),
        ),
      ),
    ); 
    foreach ($descriptors as $module => $classes) {
      foreach ($classes as $class_id => $class) {
        // serialize id for storage & parsing
        // SCID:CLASS
        $scid = 'scid:' . $class_id;
        $fieldset['items'][$scid] = array(
          '#type' => 'checkboxes',
          '#prefix' => '<div style="float: left; margin: 15px;">', 
          '#suffix' => '</div>',
          '#title' => $class['title'],
          '#description' => $class['description'],
          '#default_value' => isset($defaults[$scid]) ? 
              $defaults[$scid] : array(),
          '#options' => array(),
          '#states' => array(
            // enabled if we are attaching a list
            'enabled' => array( 
              ':input[name="attach_list"]' => array('checked' => TRUE),
            ),
          ),
        ); 
        foreach ($class['items'] as $item_id => $item) {
          // serialize id for storage & parsing
          // IID:MODULE:CLASS:ITEM
          $siid = 'iid:' . $module . ':' . $class_id . ':' . $item_id;
          $fieldset['items'][$scid]['#options'][$siid] = $item['title'];
        }
      } 
    }
  }
    
  /**
   * Implements hook_TYPE_alter()
   * 
   * @param type $data the data to be altered
   */
  function gb_maillist_mailing_list_descriptors_alter(&$data) {
    if (_WATCHDOG === 1) watchdog('gb_maillist', 'in gb_maillist_alter');
    
    if (_TEST_LISTS === 1) {
      $data['gb_maillist'] = array(
        'storage_class_test' => array(
          'title' => 'Test Mail Clients',
          'description' => 'E-Mails for testing purposes',
          'items' => array(
            'list_yahoo' => array('title' => 'Yahoo'),
            'list_hotmail' => array('title' => 'Hotmail'),
            'list_gmail' => array('title' => 'Gmail'),
            'list_inbox' => array('title' => 'Inbox.com'),
            'list_mail' => array('title' => 'Mail.com'),
            'list_aim' => array('title' => 'AOL AIM Mail'),
            'list_icloud' => array('title' => 'iCloud'),
            'list_blacklist' => array('title' => 'Blacklist Test'),
            'list_all' => array('title' => 'All'),
          ),
        ),
      );
    }
  }

  /**
   * Implements hook_TYPE_alter()
   * 
   * @param array $data an array of emails
   */
  function gb_maillist_outgoing_email_addresses_alter(&$data) {
    if (_WATCHDOG === 1) {
      watchdog('gb_maillist', 'in gb_maillist_outgoing_email_addresses_alter');
    }
    
    if (_TEST_LISTS === 1) {
      // Blacklist (remove) emails ending with @blacklist.me
      $data = array_filter($data, function ($email) {
        $needle = '@blacklist.me';
        return (substr($email, -strlen($needle)) !== $needle);
      });
    }
  }
      
  /**
   * Implements hook_provide_email_addresses_for_class_items()
   * 
   * @param string $class_id the class the items belong to
   * @param array $item_ids a list of items (email list ids)
   * 
   * @return should return an array of emails as strings
   */
  function gb_maillist_provide_email_addresses_for_class_items($class_id, 
      $item_ids) {
    if (_WATCHDOG === 1) {
      watchdog('gb_maillist', 
          'in gb_maillist_provide_email_addresses_for_class_items');
    }
    
    if (_TEST_LISTS === 1) {
      if ($class_id != 'storage_class_test') {
        return array();
      }
      
      $emails = array(
        'list_yahoo' => 'groupanizertest@yahoo.com',
        'list_hotmail' => 'groupanizertest@hotmail.com',
        'list_gmail' => 'bryan@groupanizer.com',
        'list_inbox' => 'groupanizertest@inbox.com',
        'list_mail' => 'groupanizert3st@mail.com',
        'list_aim' => 'groupanizertestaim@aim.com',
        'list_blacklist' => 'testing@blacklist.me',
        'list_icloud' => 'bp2626@icloud.com',
      );
      
      if (in_array('list_all', $item_ids)) {
        return array_values($emails);
      } else {
        return array_map(function ($item_id) use ($emails) {
          return $emails[$item_id];
        }, $item_ids);
      }
    }
    
    return array();
  }

  /**
   * Validation function for forum form
   *
   * @param type $form
   * @param type $form_state 
   */
  function gb_maillist_forum_form_validate($form, &$form_state) {
    if (_WATCHDOG === 1) {
      watchdog('gb_maillist', 'in gb_maillist_forum_form_validate');
    }
    
    if ($form_state['values']['attach_list'] !== 1) {
      return; // Not including a mailing list
    }
    
    if ($form_state['triggering_element']['#parents'][0] === 'add_alias') {
      return; // Brought here by the add_alias AJAX event
    }
    
    /** 
     * The internal drupal form validator can't seem to handle
     * '#required' changes by jQuery for the forum_form when the elements
     * are in our field set. So, we'll validate them manually. We need to make
     * sure they are valid e-mails as well.
     * 
     * We also need to check if a mailing list item was selected.
     * 
     * We also need to check if the aliases aren't duplicates, aren't empty
     * and don't contain invalid characters.
     * 
     * @todo bug report or determine if the #states code isn't correct
     */
    $values = &$form_state['values'];
    $list_options = &$form['mailing_list_setup']['list_options'];
     
    if ($values['reply_to_type'] == _REPLY_TO_TYPE_USER_DEFINED) {
      if (empty($values['reply_to_email'])) {
        $title = $list_options['reply_to_email']['#title'];
        form_set_error('reply_to_email', t("{$title} is required."));
      } elseif (!filter_var($values['reply_to_email'], FILTER_VALIDATE_EMAIL)) {
        $email = $values['reply_to_email'];
        form_set_error('reply_to_email', 
            t("'{$email}' is not a valid e-mail address."));
      }
    }
    
    if ($values['user_defined_from'] === 1) {
      if (empty($values['from_email'])) {
        $title = $list_options['from_email']['#title'];
        form_set_error('from_email', t("{$title} is required."));
      } elseif (!filter_var($values['from_email'], FILTER_VALIDATE_EMAIL)) {
        $email = $values['from_email'];
        form_set_error('from_email', 
            t("'{$email}' is not a valid e-mail address."));
      }
    }
    
    if ($values['list_type'] == _MAILING_LIST_TYPE_STANDARD) {
      if ($form_state['storage']['num_aliases'] === 0) {
        form_set_error('aliases', 
          t('At least one alias is required for standard lists'));
      }
    
      $aliases = _extract_values_with_keys_that_match_pattern(
          $form_state['values']['aliases'], '/^alias_[0-5]$/');
      $aliases_unique = array_unique($aliases); // filter duplicates
      // Get the keys that are in $aliases but not in $aliases_unique. These
      // are aliases with duplicate values.
      $duplicates = array_diff_key($aliases, $aliases_unique);
      foreach ($duplicates as $key => $value) {
        form_set_error("aliases][{$key}", t('Aliases must be unique.'));
      }
      foreach ($aliases_unique as $key => $value) {
        if (empty($value)) {
          form_set_error("aliases][{$key}", t('Aliases cannot be empty.'));
        } elseif (!preg_match('/^[a-z_]+$/', $value)) {
          form_set_error("aliases][{$key}", 
              t("Alias '{$value}' contains illegal characters."));
              $form_state['rebuild'] = TRUE;
        } elseif (_check_for_alias_record($value, isset($values['tid']) ? 
            $values['tid'] : NULL)) {
          form_set_error("aliases][{$key}", 
              t("Alias '{$value}' is already in use by another mailing list."));
        }
      }
    }
    
    $a_list_item_is_checked = FALSE;

    $list_classes = _extract_values_with_keys_that_match_pattern(
        $form_state['values'], '/^scid:.*$/');
    foreach ($list_classes as $class) {
      foreach ($class as $item_key => $item_value) {
        if ($item_key === $item_value) { // checked if value === key
          $a_list_item_is_checked = TRUE;
          break 2; // break out of inner & outter loop         
        }
      }
    }

    // We're still here, no items enabled
    if (!$a_list_item_is_checked) {
      form_set_error('items', t('At least one mailing list item is required.'));
    }
  }

  /**
   * Submit function for forum confirm delete form
   * 
   * @param type $form
   * @param type $form_state 
   */
  function gb_maillist_forum_confirm_delete_submit($form, &$form_state) {
    // Is a user logged in and authenticated?
    global $user;
    if (!(isset($user->uid)) || $user->uid === 0) {
      drupal_access_denied();
    }
    
    // Do we have the right form id?
    if ($form_state['build_info']['form_id'] != 'forum_confirm_delete') {
      return;
    }
    
    $result = _delete_all_list_records_for_tid($form_state['values']['tid']);
    if (!$result) {
      drupal_set_message(t('Failed to query the database'), 'error');
      $form_state['rebuild'] = TRUE;
    }
  }
  
  /**
   * Submit function for forum form
   * 
   * @param type $form
   * @param type $form_state 
   * 
   * @todo db_insert()->execute() return value is undefined for multi-inserts,
   *       we need to check that query and the others for success
   */
  function gb_maillist_forum_form_submit($form, &$form_state) {
    if (_WATCHDOG === 1) {
      watchdog('gb_maillist', 'in gb_maillist_forum_form_submit');
    }
    
    // Is a user logged in and authenticated?
    global $user;
    if (!(isset($user->uid)) || $user->uid === 0) {
      drupal_access_denied();
    }
    
    // Do we have the right form id?
    if ($form_state['build_info']['form_id'] != 'forum_form_forum') {
      return;
    }
    
    $values = &$form_state['values'];
    $attach = $values['attach_list'];
    $tid = $values['tid'];
    
    if (!$attach) {
      // We are not attaching a list, so, delete any previously associated
      // metadata and items in the database
      $result = _delete_all_list_records_for_tid($tid);
    } else {
      // If the user has unselected user_defined_from we don't want to write
      // the from email because that's all we store in the database. If it's
      // there we will assume user_defined_from is 1 later.
      if ($values['user_defined_from'] !== 1) {
        $values['from_email'] = NULL;
      }
      // We are attaching a list
      // build and write our query for gb_maillist_metadata
      // db_merge will handle update & insert
      $result = _build_and_insert_list_records_for_tid($tid, $values);
    }
    if (!$result) {
      drupal_set_message(t('Failed to query the database'), 'error');
      $form_state['rebuild'] = TRUE;
    }
  }

  /**
   * Implements hook_form_FORM_ID_alter()
   * 
   * @param array $form nested array of form elements that comprise the form
   * @param array $form_state an array containing the current state of the form
   * @param string $form_id string representing the name of the form itself
   */
  function gb_maillist_form_forum_form_forum_alter(&$form, 
      &$form_state, $form_id) {
    if (_WATCHDOG === 1) {
      watchdog('gb_maillist', 'in gb_maillist_form_forum_form_forum_alter');
    }
    
    $descriptors = _fetch_mailing_list_descriptors();
    // Typically NULL for new forms, fill to current values in db on edit
    $defaults = _fetch_forum_form_default_values(
        isset($form['tid']) ? $form['tid']['#value'] : NULL);
    _insert_mailing_list_elements($form, $form_state, $descriptors, $defaults);
    
    $form['#submit'][] = 'gb_maillist_forum_form_submit';
    $form['#validate'][] = 'gb_maillist_forum_form_validate';
  }

  /**
   * Implements hook_form_FORM_ID_alter()
   * 
   * @param array $form nested array of form elements that comprise the form
   * @param array $form_state an array containing the current state of the form
   * @param string $form_id string representing the name of the form itself
   */
  function gb_maillist_form_forum_confirm_delete_alter(&$form, 
      &$form_state, $form_id) {
     // Insert our submit handler for deleting of forums
     $form['#submit'][] = 'gb_maillist_forum_confirm_delete_submit';
  }
      
  /**
   * Implements hook_form_FORM_ID_alter()
   * 
   * @param array $form nested array of form elements that comprise the form
   * @param array $form_state an array containing the current state of the form
   * @param string $form_id string representing the name of the form itself
   */
  function gb_maillist_form_forum_node_form_alter(&$form, 
      &$form_state, $form_id) {
    // Hide the element that lets the user choose which forum to post to.
    $form['taxonomy_forums']['#type'] = 'hidden';
  }   
 
  /** 
   * Implements hook_page_alter 
   */
  function gb_maillist_page_alter(&$page) {
    // Try and read the taxonomy from the path forum/%
    // and insert a URL to a page to view the emails!
    $term = menu_get_object('forum_forum', 1);
    if (!empty($term)) {
      if ($term->vocabulary_machine_name === 'forums') {
        // Append our link
        global $base_url;
        $tid = $term->tid;
        $t = t('View the e-mails associated with this list');
        $markup = "<a href =\"{$base_url}/mailing-list/view/{$tid}\">{$t}</a";
        $page['content']['system_main']['main']['#markup'] .= $markup;
      }
    }
  }
      
  /**
   * Implemenets hook menu
   */
  function gb_maillist_menu() {
    if (_WATCHDOG === 1) watchdog('gb_maillist', 'in gb_maillist_menu');
    
    return array(
      'mailing-list/view/%' => array(
        'title' => t('View e-mails assocated with a mailing list'),
        'page callback' => 'gb_maillist_view_list_page',
        'page arguments' => array(2), // tid as argument
        'access arguments' => array('administer forums'),
        'file' => 'gb_maillist.pages.inc',
        'type' => MENU_CALLBACK,
      ),
      'mailing-list/export/%' => array(
        'title' => t('Export a mailing list to CSV'),
        'page callback' => 'gb_maillist_export_list_page',
        'page arguments' => array(2), // tid as argument
        'access arguments' => array('administer forums'),
        'file' => 'gb_maillist.pages.inc',
        'type' => MENU_CALLBACK,
      ),
      'mailing-list/unsubscribe/%/%' => array(
        'title' => t('Unsubscribe from a mailing list'),
        'page callback' => 'gb_maillist_unsubscribe_from_list_page',
        'page arguments' => array(2, 3), // nid & email as arguments
        'access arguments' => array(TRUE),
        'file' => 'gb_maillist.pages.inc',
        'type' => MENU_CALLBACK,
      ),
    );
  }
      
  /**
   * Implements hook_admin_paths_alter()
   */
  function gb_maillist_admin_paths_alter(&$paths) {
    if (_WATCHDOG === 1) {
      watchdog('gb_maillist', 'in gb_maillist_admin_paths_alter');
    }
    
    $paths['mailing-list/view/%'] = TRUE;
    $paths['mailing-list/export/%'] = TRUE;
    $paths['mailing-list/unsubscribe/%/%'] = TRUE;
  }
  
  /**
   * Implements hook_admin_paths()
   */
  function gb_maillist_admin_paths() {
    if (_WATCHDOG === 1) {
      watchdog('gb_maillist', 'in gb_maillist_admin_paths');
    }
    
    return array(
      'mailing-list/view/%' => TRUE,
      'mailing-list/export/%' => TRUE,
      'mailing-list/unsubscribe/%/%' => TRUE,
    );
  }

  /** 
   * Implements hook_theme() 
   */
  function gb_maillist_theme($existing, $type, $theme, $path) {
    return array(
      'gb_maillist_aliases' => array(
        'render element' => 'aliases',
      ),
    );
  }
  
  /**
   * Implements hook_node_insert()
   */
  function gb_maillist_node_insert($node) {
    if (_WATCHDOG === 1) {
      watchdog('gb_maillist', 'in gb_maillist_node_insert');
    }
    
    _node_update_and_insert($node);
  }
  
  /**
   * Implements hook_node_update()
   */
  function gb_maillist_node_update($node) {
    if (_WATCHDOG === 1) {
      watchdog('gb_maillist', 'in gb_maillist_node_update');
    }
    
    _node_update_and_insert($node);
  }
  
  /**
   * Implements hook_comment_insert()
   */
  function gb_maillist_comment_insert($comment) {
    if (_WATCHDOG === 1) {
      watchdog('gb_maillist', 'in gb_maillist_comment_insert');
    }
    
    _comment_update_and_insert($comment);
  }
  
  /**
   * Implements hook_comment_update()
   */
  function gb_maillist_comment_update($comment) {
    if (_WATCHDOG === 1) {
      watchdog('gb_maillist', 'in gb_maillist_comment_update');
    }
    
    _comment_update_and_insert($comment);
  }
  